1:
一个进程就是一个程序的运行实例。
线程是不能单独存在的，它是由进程来启动和管理的。线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。
进程和线程关系的4个特点
1，进程中的任意一线程执行出错，都会导致整个进程的崩溃。   2，线程之间共享进程中的数据。
3，当一个进程关闭之后，操作系统会回收进程所占用的内存。   4，进程之间的内容相互隔离。
目前的多进程架构：1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程和多个插件进程

2：
1，互联网中的数据是通过数据包来传输的，数据包在传输过程中容易丢失或出错。
2，IP负责把数据包送到目的主机
3，UDP负责把数据包送达具体应用
4，而 TCP 保证了数据完整地传输，它的连接可分为三个阶段：建立连接（三次握手）、传输数据（接收端需要对每个数据包进行确认操作）和断开连接（四次挥手）。
你怎么理解 HTTP 和 TCP 的关系？
HTTP协议属于应用层，TCP协议属于传输层，HTTP协议位于TCP协议的上层。tcp是个梯子，http就是利用梯子来搬运货物

3：
1，为什么很多站点第二次打开速度会很快
如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据（DNS缓存和页面资源缓存）。
浏览器资源缓存：
第一次请求，当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源，Cache-Control中的Max-age参数来设置缓存过期时长。
在缓存资源未过期的情况下，如果再次请求该资源，直接返回缓存中的资源给浏览器，如果缓存过期了，浏览器会继续发起网络请求，并且在http请求头中带上If-None-Match字段，
服务器收到请求后，会根据If-None-Match的值来判断请求的资源是否有更新。如果没有更新，返回304状态码，代表这个缓存可以继续使用。如果有更新，服务器就返回最新资源给浏览器
2，登录状态是如何保持的
1，用户打开登录页面，在登录框里填入用户名和密码，点击确定按钮。点击按钮会触发页面脚本生成用户登录信息，然后调用 POST 方法提交用户登录信息给服务器。
2，服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。
3，浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把UID=3431uad保持到本地。
4，当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。
5，服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
6，浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。
3，如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？
1 首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过ping curl看看对应的时延高不高。
2 然后通过wireshake看看具体哪里出了问题。
3 假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。
还可以看chrome network面板，看瀑布图每个阶段的含义。举个例子 Content Download 如果太长，很有可能是下载的资源太大，但也有可能是网络慢导致的下载太慢，简单计算一下，再例如 Waiting (TTFB) 这个太长的话，有可能是网络慢，或者就是后端处理时间过长导致的

4：
Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。
同一站点：根域名和协议一样
用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。
从输入 URL 到页面展示，这中间发生了什么？
结合老师的讲义，自己总结了下，不考虑用户输入搜索关键字的情况：
    1，用户输入url并回车
    2，浏览器进程检查url，组装协议，构成完整的url
    3，浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
    4，网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程
    5，如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：
        5.1 进行DNS解析，获取服务器ip地址，端口（端口是通过dns解析获取的吗？这里有个疑问）
        5.2 利用ip地址和服务器建立tcp连接
        5.3 构建请求头信息
        5.4 发送请求头信息
        5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容
    6，网络进程解析响应流程；
        6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步
            （301/302跳转也会读取本地缓存吗？这里有个疑问），如果是200，则继续处理请求。
        6.2 200响应处理：
            检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行
            后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。
    7，准备渲染进程
        7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程
    8. 传输数据、更新状态
        8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
        8.2 渲染进程接收完数据后，向浏览器发送“确认提交”
        8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。此时的web页面是空白页
    9， 渲染阶段
        渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，
        两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来
