Vue.$watch: 首先会判断传入的回掉函数是否为一个对象（如果是，处理一下。将第二个参数提取成回掉函数的形式，这样可以方便统一处理）。接着
$watch方法内部会创建一个watcher实例，由于该实例是用户手动调用$watch方法创建而来的，所以给options添加user属性并赋值为true，
用于区分用户创建的watcher实例和Vue内部创建的watcher实例。接着判断如果用户在选项参数options中指定的immediate为true，则立即用被观察数据当前的值触发回调。
最后返回一个取消观察函数unwatchFn，用来停止触发回调。
这个取消观察函数unwatchFn内部其实是调用了watcher实例的teardown方法，那么我们来看一下这个teardown方法是如何实现的（this.deps[i].removeSub(this) ）：
在之前介绍变化侦测篇的文章中我们说过，谁读取了数据，就表示谁依赖了这个数据，那么谁就会存在于这个数据的依赖列表中，当这个数据变化时，就会通知谁。
也就是说，如果谁不想依赖这个数据了，那么只需从这个数据的依赖列表中把谁删掉即可。具体方法: Watcher实例中有一个deps属性中存了相应的依赖管理器。只要遍历
deps中相应的依赖管理器去调用removeSub方法去将此watcher实删除即可。
如何实现深度观察呢？
我们知道，要想让数据变化时通知我们，那我们只需成为这个数据的依赖即可，因为数据变化时会通知它所有的依赖，那么如何成为数据的依赖呢，很简单，读取一下数据
即可。也就是说我们只需在创建watcher实例的时候把obj对象内部所有的值都递归的读一遍，那么这个watcher实例就会被加入到对象内所有值的依赖列表中，之后当对象
内任意某个值发生变化时就能够得到通知了。


Vue.set(target, propertyName / index, value)
原理：首先判断传入的target是否符合条件，如果为undefined, null或者原始类型，则抛出警告。接着判断传入的target是数组并且key是
有效索引的话，利用splice方法将传入的索引key对应的val值添加进数组（因为数组的splice方法已经被我们创建的拦截器重写了）。
如果传入的target是对象的话，先会判断传入的key是否已经在target中，如果已经在了，那就不是新增的属性，直接修改属性值。接下来判断
target的__ob__属性，如果为false，代表target不是响应式对象，只需添加上新的属性即可。假如__ob__属性为true。代表target是响应式
对象，会调用defineReactive方法。此方法内部会调用Object.defineProperty将此属性转化为响应式，然后再通知依赖更新。

vm.$delete(target, propertyName / index):
原理：首先判断target是否符合条件，如果target不存在，或者target是原始值，则抛出警告。
如果target是数组并且传入的key是有效索引的话，就利用splice方法将key对应的值删除。
假如target是个对象，并且key也存在于target中，同时判断当前的target是否为响应式对象，如果是的话，则通知依赖更新。否则删除完不通
知更新。