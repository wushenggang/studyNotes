21：
http请求基础流程：发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，
然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。

优化时间线上耗时项 Network - Timing
1，排队(Queuing时间过久)
大概率是由浏览器为每个域名最多维护 6 个连接导致的，可以采用域名分片技术，或者把站点升级到http2
2，第一字节时间(TTFB)时间过久
原因有可能如下：
（1）：服务器生成页面数据的时间过久
（2）网络的原因
（3）发送请求头时带上了多余的用户信息（比如一些多余的Cookie信息，加大了服务器的处理时长）
第一种问题可以想办法提高服务器的处理速度，比如增加各种缓存的技术，第二种问题可以使用CDN来缓存一些静态文件。第三种可以在请求时减少一些不必要的Cookie信息
3，Content Download时间过久
能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。
22：
CSS不阻塞dom的生成。CSS不阻塞js的加载，但是会阻塞js的执行。js会阻塞dom的生成，也就是会阻塞页面的渲染，那么css也有可能会阻塞页面的渲染。
如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，也不会阻塞JS，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，
而不是在解析DOM的时候，并行解析CSS。并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。
所以应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，
从而使页面尽快的渲染完成。

async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前
defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前

总结：
1. 首先介绍了什么是DOM（表述渲染引擎内部数据结构，它将Web页面和JavaScript脚本连接起来，并过滤不安全内容）、DOM树如何生成（网络进程和渲染进程建立一个流式管道，HTML解析器直接解析，不需要等待text / html类型的接口接受完毕再进行解析），第一步：通过分词器将字节流转换为Token；第二步：将Token解析为DOM节点；第三步：将DOM节点添加到DOM树中。
2. JavaScript是如何影响DOM生成的？暂停html解析，下载解析执行完毕js之后再进行html解析（如果这期间使用到了cssDom，需要等待相应css过程）。预解析线程的优化（提前加载相应js css文件）
3. 渲染引擎还有一个安全检查模块XSSAuditor用来检测词法安全的

23：
如果想要缩短白屏时长，可以有以下策略：
1，尽量减少文件大小，比如通过webpack等工具移除一些不必要的注释，并压缩javascript文件。
2，还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer
3，对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。

24:
需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。
这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

1, 常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，
比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。这也是 CSS 动画比 JavaScript 动画高效的原因。
2, 可以使用 will - change 来告诉渲染引擎你对该元素做一些特效变换，CSS 代码如下：
.box {
  will - change: transform, opacity;
}
这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，
渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。

25:
一个页面从生命周期的维度主要分为三个阶段：加载阶段、交互阶段、关闭阶段。
1. 加载阶段影响网页首次渲染的关键资源几个指标：个数、大小、RTT（round trip time）。通常一个HTTP的数据包在14kb左右。
优化方式：（1）如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性
（2）JavaScript 和 CSS 改成内联的形式
（3）同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志
（4）可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容
（5）还可以使用 CDN 来减少每次 RTT 时长
2. 交互阶段的优化主要是指渲染进程渲染帧速度。如何让单个帧生成的速度变快呢？
   * 减少JavaScript脚本执行时间
方法：（1）可以将一次执行的函数分解为多个任务，使每次执行时间变短 （2）使用Web Workers（主线程之外的线程，但web workers中没有DOM，CSSOM环境，所以无法操作DOM，可以将一些和DOM操作无关且费时的任务放入进行执行）
  * 避免强制同步布局，添加 删除dom后计算样式布局是在另外一个任务中执行的，这时候获取样式信息，会将其变成同步任务。
  * 避免布局抖动
  * 合理利用CSS合成动画, 是直接在合成线程上执行的（标识 will - change 单独生成一个图层）
  * 避免频繁的垃圾回收。会占用主线程（尽量避免临时垃圾数据，优化存储结构，避免小颗粒对象产生）

26：
虚拟DOM：
1，将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。
2，变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。
3，在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。
如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。
虚拟 DOM 都解决了哪些问题？    1. 频繁更新dom引起的性能问题  2. 将真实DOM和js操作解耦，减少js操作dom复杂性。
为什么会出现虚拟DOM？javascript直接操作DOM可能会引起重排 重绘等操作（强制同步布局和布局抖动）引起性能问题。这是需要一个中间层来优化dom的操作（批量更新dom，优化更新dom细节），虚拟DOM就呼之欲出了。

27：
PWA：它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。

28：
使用WebComponent来实现组件化
你是怎么看待 WebComponents 和前端框架（React、Vue）之间的关系的 ?
  在没有webcomponent的时候，通过react和vue基于当前的前端特性去实现组件化，他们之间是互相影响和借鉴的，最终react和vue也会向webcomponent标准的方向演进。
但是现在由于webcomponent的浏览器支持还不是太好，所以现阶段它们还是会并存的

29：
http / 0.9的一个完整请求流程：
1，因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。
2，建立好连接之后，会发送一个 GET 请求行的信息，如GET / index.html用来获取 index.html。
3，服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。
4，HTML 文档传输完成后，断开连接。
特点：
1，只有一个请求行，并没有 HTTP 请求头和请求体
2，服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
3，返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。
http / 1.0：
支持多种类型的文件下载是 HTTP / 1.0 的一个核心诉求，所以HTTP / 1.0 引入了请求头和响应头
请求头：
accept: text / html                             //期望服务器返回 html 类型的文件
accept - encoding: gzip, deflate, br            //期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式
accept - Charset: ISO - 8859 - 1, utf - 8              //期望返回的文件编码是 UTF-8 或者 ISO-8859-1
accept - language: zh - CN, zh                     //期望页面的优先语言是中文
响应头：
content - encoding: br                          //表示服务器采用了 br 的压缩方法
content - type: text / html; charset = UTF - 8        //表示服务器返回的是 html 文件
新增的几个特性：
1，引入状态码
2，提供了Cache机制
3，因为需要统计客户端的基础信息，比如window和macOS的用户数量，所以在请求头中加入了用户代理字段
http / 1.1:
1, 增加了持久连接的方法, 它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。connection: keep - alive / close
2, 不成熟的 HTTP 管线化(如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。)
3, 提供虚拟主机的支持(HTTP / 1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。)
4, 对动态生成的内容提供了完美支持(很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。引入chunk transfer机制来解决这个问题)
5, 引入了客户端 Cookie 机制和安全机制。
http / 1.1为网络效率做了大量的优化，最核心的有如下三种方式：
1，增加了持久连接 2，浏览器为每个域名最多同时维持6个TCP连接 3，使用CDN的实现域名分片机制

30：
http / 1.1的主要问题
对带宽的利用率却并不理想，原因如下：
1，TCP 的慢启动。（一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。）
2，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。（多条TCP连接之间不能协商让哪些关键资源优先下载，有可能会影响关键资源的下载速度）
3，HTTP / 1.1 队头阻塞的问题。（如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求）
http / 2特性
1，一个域名只使用一个TCP长连接（只需一次TCP慢启动）
2，多路复用机制（实现资源的并行请求，解决了http / 1.1的队头阻塞问题）
多路复用的实现
1，首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
2，这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
3，服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
4，然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
5，同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
6，浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。
以上看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。
http / 2其他特性
1，可以设置请求的优先级
2，服务器推送
3，头部压缩

31：
虽然 HTTP / 2 解决了 HTTP / 1.1 中的队头阻塞问题，但是 HTTP / 2 依然是基于 TCP 协议的，
而 TCP 协议依然存在数据包级别的队头阻塞问题，那么你觉得 TCP 的队头阻塞是如何影响到 HTTP / 2 性能的呢？
在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。（你可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输）

32:
同源：如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。
同源策略
1，会隔离不同源的DOM（限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作）
2，隔离页面数据（Cookie、IndexDB、LocalStorage）
3，网络通信（限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点）
页面安全策略原型：
1，页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度
2，使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略（CORS），让其可以安全地进行跨域操作
3，两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信

33：
什么是XSS攻击：XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器
恶意脚本可以做的事情：
1，可以窃取Cookie信息
2，可以监听用户行为
3，可以修改DOM伪装假的登录窗口
4，可以在页面内生成浮窗广告
XSS攻击的方式：1，存储型XSS攻击 2，反射型XSS攻击 3，基于DOM的XSS攻击
如何阻止XSS攻击：
1，服务器对输入脚本进行过滤或转码
2，充分利用内容安全策略(CSP)需要配置网络服务器返回Content - Security - Policy  HTTP头部，或者前端通过 < meta > 元素来配置
CSP的功能
（1）限制加载其他域下的资源文件
（2）禁止向第三方域提交数据
（3）禁止执行内联脚本和未授权的脚本
（4）还提供了上报机制，可以帮助我们尽快发现有哪些XSS攻击
3，使用HttpOnly属性
可以将某些Cookie设置为HttpOnly标志，HttpOnly是服务器通过Http头来设置的（可以在加在set - cookie属性值里）
使用了HttpOnly标记的Cookie只能使用在Http请求过程中，所以无法通过javascript来读取这段cookie
4，可以通过添加验证码防止脚本冒充用户提交危险操作

34：
什么是CSRF攻击：CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。
和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。
通常当用户打开了黑客的页面后，有三种方式去实施CSRF攻击
1，自动发起Get请求 2，自动发起post请求 3，引诱用户点击链接
如何防止CSRF攻击：
1，充分利用好Cookie的SameSite属性（Cookie是浏览器和服务器之间维护登陆状态的一个关键数据）
SameSite的功能：
（1）如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；
（2）如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。
可以通过在http响应头中的set - cookie字段中带上SameSite选项
SameSite选项通常有Strict, Lax, None三个值
Strict（浏览器完全禁止第三方Cookie）
Lax（在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。）
None 任何情况下都会发送Cookie数据
2，在服务器端验证请求的来源站点（根据http请求头中的Origin和Referer属性，优先判断Origin属性）
3，CSRF Token

35：
安全沙箱： 将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱（让渲染进程在执行过程中无法访问或者修改操作系统中的数据）
你认为安全沙箱能防止 XSS 或者 CSRF 一类的攻击的吗？为什么？
安全沙箱是不能防止 XSS 或者 CSRF 一类的攻击，
安全沙箱的目的是隔离渲染进程和操作系统，让渲染进程没有访问操作系统的权利
XSS 或者 CSRF 主要是利用网络资源获取用户的信息，这和操作系统没有关系的

36：
https：在http协议栈中引入安全层（ssL / TLS），安全层是对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作
在安全层采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥。采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。
总结一下 HTTPS 的握手过程
1. 首先是tcp的三次握手建立连接
2. client发送random1 + 支持的加密算法集合（clientHello）
3. server收到信息，返回选择一个加密算法 + random2（serverHello）+ 证书 + 确认
4. clent验证证书有效性，并用random1 + random2生成pre - master通过服务器公钥加密 发送给server
5. server收到premaster，根据约定的加密算法对random1 + random2 + premaster（解密）生成master - secret，然后发送预定成功
6. client收到生成同样的master - secert，对称加密秘钥传输完毕

