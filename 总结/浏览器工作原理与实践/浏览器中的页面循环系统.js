15：
同步锁：为了保证共享数据在同一时刻只被一个线程使用

流程：有一个消息队列；IO 线程中产生的新任务添加进消息队列尾部；渲染主线程会循环地从消息队列头部中读取任务，执行任务。
通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列
结合消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？
每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到该列表中，
等宏任务快执行结束之后，会执行微任务列表，所以微任务依然运行在当前宏任务的执行环境中，
这个特性会导致宏任务和微任务有一些本质上的区别！我们后面再介绍，你可以重点关注下。
1. 单线程处理安排好的同步任务
2. 引入事件循环接受新的任务
3. 引入消息队列处理其他进程发来的任务
4. 引入宏任务和微任务解决任务优先级的问题
5. 通过Js回调功能解决单个js任务执行时间过长的问题

问题1：如何处理高优先级的任务
采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。需要用到微任务（如上）
问题2：如何解决单个任务执行时长过久的问题。
因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。
JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。

16:
浏览器的页面是通过消息队列和事件循环系统来驱动的。settimeout的函数会被加入到延迟消息队列中，
等到执行完Task任务之后就会执行延迟队列中的任务。然后分析几种场景下面的setimeout的执行方式。
延迟队列中任务的执行时机：处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，
然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程
clearTimeout原理: 就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。

1. 如果执行一个很耗时的任务，会影响延迟消息队列中任务的执行
2. 存在嵌套带调用时候，系统会设置最短时间间隔为4s（超过5层）
3. 未激活的页面，setTimeout最小时间间隔为1000ms
4. 延时执行时间的最大值2147483647（32bit来存储值），溢出会导致定时器立即执行
5. setTimeout设置回调函数this会是回调时候对应的this对象，可以使用箭头函数解决

了解下 requestAnimationFrame 的工作机制，并对比 setTimeout，然后分析出 requestAnimationFrame 实现的动画效果比 setTimeout 好的原因 ?
  requestAnimationFrame 提供一个原生的API去执行动画的效果，它会在一帧（一般是16ms）间隔内根据选择浏览器情况去执行相关动作。即按照系统刷新的节奏调用。
setTimeout是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化。

17：
XMLHttpRequest：
渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，
会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。
XMLHttpRequest使用过程中的"坑"
1，跨域问题（在 A 站点中去访问不同源的 B 站点的内容）。默认情况下，跨域请求是不被允许的
2，HTTPS混合内容问题（通过 HTML 文件加载的混合资源(比如http资源) ，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求）

18：
// 页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，
宏任务实时性不高的原因：可能会在队列中被插入很多系统级的任务。所以很难控制执行开始时间
微任务可以在实时性和效率之间做一个有效的权衡。
异步回调的两种方式：
1，第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。(setTimeout, XMLHttpRequest)
2，第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。
微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。
产生微任务的两种方式：1，MutationObserver 2，Promise.resolve() 或者 Promise.reject()
微任务队列何时被执行：
// 通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，
// JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。
结论：
1，微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
2，微任务的执行时长会影响到当前宏任务的时长。
如果采用 setTimeout 创建宏任务来触发回调的话, 在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。
MutationObserver 采用了“异步 + 微任务”的策略。
MutationObserver:
作用：监视DOM变化并及时做出响应
刚开始用轮询(setTimeout, setInterval) ，后来用MutationEvent。Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，属于同步调用。有巨大性能问题。
首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用。解决了同步操作的性能问题。这时会有一个实时性问题。
所以在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。所以通过微任务解决了实时性的问题


19:
产生地狱回调的原因：1，多层嵌套的问题 2，每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。
Promise 通过回调函数延迟绑定、回调函数返回值穿透和错误“冒泡”技术解决了上面的两个问题。
1，Promise中为什么要引入微任务？
由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，
便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务
2、Promise 中是如何实现回调函数返回值穿透的？
首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），
将前一个promise的data值赋给新建的promise
3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获
promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；
若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误。

20:
生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。
async / await 技术背后的秘密就是 Promise 和生成器应用，往低层说就是微任务和协程应用
async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。async 函数返回的是一个 Promise 对象。
generator 函数是如何暂停执行程序的？
答案是通过协程来控制程序执行。generator 函数是一个生成器，执行它会返回一个迭代器，这个迭代器同时也是一个协程。一个线程中可以有多个协程，但是同时只能有一个协程在执行。
线程的执行是在内核态，是由操作系统来控制；协程的执行是在用户态，是完全由程序来进行控制，通过调用生成器的next()方法可以让该协程执行，通过yield关键字可以让该协程暂停，
交出主线程控制权，通过return 关键字可以让该协程结束。协程切换是在用户态执行，而线程切换时需要从用户态切换到内核态，在内核态进行调度，协程相对于线程来说更加轻量、高效。
async function实现原理？
async function 是通过 promise + generator 来实现的。generator 是通过协程来控制程序调度的。在协程中执行异步任务时，先用promise封装该异步任务，如果异步任务完成，
会将其结果放入微任务队列中，然后通过yield 让出主线程执行权，继续执行主线程js，主线程js执行完毕后，会去扫描微任务队列，如果有任务则取出任务进行执行，
这时通过调用迭代器的next(result)方法，并传入任务执行结果result，将主线程执行权转交给该协程继续执行，并且将result赋值给yield 表达式左边的变量，
从而以同步的方式实现了异步编程。所以说到底async function 还是通过协程+微任务 + 浏览器事件循环机制来实现的。