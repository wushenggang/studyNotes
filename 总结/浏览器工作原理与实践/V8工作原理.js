12:
Javascript是一种弱类型的，动态的语言
栈空间是用来存储执行上下文的，原始类型存放在栈中
引用类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，
是通过栈中的引用地址来访问的，相当于多了一道转手流程。
为什么一定要分“堆”和“栈”两个存储空间呢？
因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，
那么会影响到上下文切换的效率
栈空间小，堆空间大
如何实现深拷贝：
1，JOSN.parse(JSON.stringify(obj))
2, 递归遍历对象
3，Object.assigin()这种方法只能拷贝一层，有嵌套的情况就不适用了

13：
垃圾回收策略一般分为手动回收和自动回收，java python JavaScript等高级预言为了减轻程序员负担和出错
概率采用了自动回收策略。JavaScript的原始类型数据和引用数据是分别存储在栈和椎中的，由于栈和堆分配空
间大小差异，垃圾回收方式也不一样。栈中分配空间通过ESP（记录当前执行状态的指针）的向下移动销毁保存在
栈中数据；堆中垃圾回收主要通过副垃圾回收器（新生代（生存时间短，小的对象））和主垃圾回收器（老生代
（生存时间久，大的对象））负责的，副垃圾回收器采用scavenge算法将区域分为对象区域和空闲区域，首先要
对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空
闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制
后空闲区域就没有内存碎片了。然后通过两个区域的反转让新生代区域无限使用下去。主垃圾回收器采用
Mark - Sweep（标记 - 清除）算法进行空间回收的。首先是标记过程阶段。标记阶段就是从一组根元素开始，递
归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。由
于会产生大量不连续的内存碎片，又产生了标记 - 整理算法。无论是主副垃圾回收器的策略都是标记 - 清除 - 
整理三个大的步骤。另外还有新生代的晋升策略（两次未清除的），大对象直接分配在老生代。

全停顿：
副垃圾回收和主垃圾回收都是运行在主线程上的。一旦垃圾回收，会使别的js脚本暂停下来。这就是全停顿
（新生代影响不大）
为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和
 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）
 算法使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，
 可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务
 而感受到页面的卡顿了。

14:
AST（编译器和解释器可以理解的。    代码的结构化表示）
Babel 的工作原理就是先将 ES6 源码转换为 AST（抽象语法树），然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。
ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。
V8 是如何执行一段 JavaScript 代码的：V8 依据 JavaScript 代码生成 AST 和执行上下文，再基于 AST 生成字节码，然后通过解释器执行字节码，通过编译器来优化编译字节码。
JavaScript的性能优化：
1，提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互。
2，避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程。
3，减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。
你是怎么理解“V8 执行时间越久，执行效率越高”这个性质的？
执行时间越长，执行效率越高。是因为更多的代码成为热点代码之后，转为了机器码来执行

