双向绑定:
在vue2中使用Object.defineProperty实现
缺陷：
1，无法检测到新的属性的添加和删除
2，无法监听数组的变化      
3，嵌套深的话，需要深度遍历，浪费内存
vue3中通过proxy对象来监听属性的变化，实现数据的监控。在get函数里进行依赖收集，
在set里面用于触发依赖更新。
vue3的优势，加了proxy后，可以直接拦截所有对象上面的操作，对数组也是支持的。同时有一个
缓存的机制，多层对象嵌套的时候可以使用懒代理。在这里比较需要注意的点是，在vue3源码里面，
对数组方法里面的add和delete单独做了处理。因为你改变了数组长度的时候，除了去触发数组内容的
set方法之外，还会触发数组长度的set方法。所以这个时候是需要去避免多次调用set方法的。


虚拟DOM：
在2里面可以保证组件更新的最小化，但是当一个组件内部有动态变量进行更新的时候，需要遍历整个
组件的DOM树来进行一个patch去对比，由于这个特性，在一些组件里面大部分都是静态节点，只有少部分
动态节点的情况下，整个组件的DOM树遍历是比较浪费性能的。而且要明确的是，在2里面是VDOM的性能和模板
的大小是成正相关的，和动态节点的数量是无关的。

vue3在对VDOM生成DOM节点的时候，它会给每一个动态节点加一个标志，

vue3对虚拟DOM主要做了哪些优化工作呢？
首先是将AST语法树上面的节点结构，根据动态指令，比如说if,for,slot切割为嵌套
的一些区块，每一个区块用一个数组来进行动态节点的保存，在3里面编译器会主动
检测静态节点，将静态节点提升到render函数之外。可以大大提高性能。同时vue3会给
元素标记一个PatchFlag，无论嵌套的多深，动态节点都是直接跟根节点绑定的。这样
只需要去遍历动态节点进行更新就可以。新策略将虚拟DOM节点渲染的性能与模板的大小
进行了解耦，变为与动态节点的数量有关。比2的性能大概高了2到5倍


Tree-Shaking:
 2.0的现有限制是，无论你使不使用一些功能和方法，都要把它下下来。那在3的时候，它
 将全局的API和内部的一些组件都通过ES的模块来进行导出。webpack这种打包工具在
 打包的时候，Tree-Shaking就会更加友好。

 Composition API:
 主要有6个，比较要注意setup这个函数，替代了2里面我们常用的data()。同时3里面beforeCreate,
 created两个生命周期，也将直接替换为setup()。

 使用TypeScript

 内部模块的解耦：
	2.0的隐式耦合已经很严重了， 我们单独去理解源码的一部分的确比较困难，
	在3里面，用到了一个monorepo结构。monorepo结构是把所有的模块都统一放在
	一个主分支上面。如果有什么新的功能，拉一个分支出来去实现那个新的功能。