15：
同步锁：为了保证共享数据在同一时刻只被一个线程使用
通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列
结合消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？
每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到改列表中，
等宏任务快执行结束之后，会执行微认为列表，所以微任务依然运行在当前宏任务的执行环境中，
这个特性会导致宏任务和微任务有一些本质上的区别！我们后面再介绍，你可以重点关注下。
1. 单线程处理安排好的同步任务
2. 引入事件循环接受新的任务
3. 引入消息队列处理其他进程发来的任务
4. 引入宏任务和微任务解决任务优先级的问题
5. 通过Js回调功能解决单个js任务执行时间过长的问题

16:
浏览器的页面是通过消息队列和事件循环系统来驱动的。settimeout的函数会被加入到延迟消息队列中，
等到执行完Task任务之后就会执行延迟队列中的任务。然后分析几种场景下面的setimeout的执行方式。
1. 如果执行一个很耗时的任务，会影响延迟消息队列中任务的执行
2. 存在嵌套带调用时候，系统会设置最短时间间隔为4s（超过5层）
3. 未激活的页面，setTimeout最小时间间隔为1000ms
4. 延时执行时间的最大值2147483647，溢出会导致定时器立即执行
5. setTimeout设置回调函数this会是回调时候对应的this对象，可以使用箭头函数解决

了解下 requestAnimationFrame 的工作机制，并对比 setTimeout，然后分析出 requestAnimationFrame 实现的动画效果比 setTimeout 好的原因 ?
  requestAnimationFrame 提供一个原生的API去执行动画的效果，它会在一帧（一般是16ms）间隔内根据选择浏览器情况去执行相关动作。即按照系统刷新的节奏调用。
setTimeout是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化。

17：
XMLHttpRequest：
渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，
会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。
XMLHttpRequest使用过程中的"坑"
1，跨域问题
2，HTTPS混合内容问题（通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求）

18：
微任务可以在实时性和效率之间做一个有效的权衡。
异步回调的两种方式：
1，第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。(setTimeout, XMLHttpRequest)
2，第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。
微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。
产生微任务的两种方式：1，MutationObserver 2，Promise.resolve() 或者 Promise.reject()
微任务队列何时被执行：
通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，
JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。
结论：
1，微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
2，微任务的执行时长会影响到当前宏任务的时长。
如果采用 setTimeout 创建宏任务来触发回调的话, 在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。
MutationObserver 采用了“异步 + 微任务”的策略。