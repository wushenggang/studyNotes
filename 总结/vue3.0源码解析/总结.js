双向绑定:
在vue2中使用Object.defineProperty实现
缺陷：
1，无法检测到新的属性的添加和删除
2，无法监听数组的变化
3，嵌套深的话，需要深度遍历，浪费内存
vue3中通过proxy对象来监听属性的变化，实现数据的监控。在get函数里进行依赖收集，
在set里面用于触发依赖更新。
vue3的优势，加了proxy后，可以直接拦截所有对象上面的操作，对数组也是支持的。同时有一个
缓存的机制，多层对象嵌套的时候可以使用懒代理。在这里比较需要注意的点是，在vue3源码里面，
对数组方法里面的add和delete单独做了处理。因为你改变了数组长度的时候，除了去触发数组内容的
set方法之外，还会触发数组长度的set方法。所以这个时候是需要去避免多次调用set方法的。


虚拟DOM：
在2里面可以保证组件更新的最小化，但是当一个组件内部有动态变量进行更新的时候，需要遍历整个
组件的DOM树来进行一个patch去对比，由于这个特性，在一些组件里面大部分都是静态节点，只有少部分
动态节点的情况下，整个组件的DOM树遍历是比较浪费性能的。而且要明确的是，在2里面是VDOM的性能和模板
的大小是成正相关的，和动态节点的数量是无关的。

vue3在对VDOM生成DOM节点的时候，它会给每一个动态节点加一个标志，

vue3对虚拟DOM主要做了哪些优化工作呢？
首先是将AST语法树上面的节点结构，根据动态指令，比如说if,for, slot切割为嵌套
的一些区块，每一个区块用一个数组来进行动态节点的保存，在3里面编译器会主动
检测静态节点，将静态节点提升到render函数之外。可以大大提高性能。同时vue3会给
元素标记一个PatchFlag，无论嵌套的多深，动态节点都是直接跟根节点绑定的。这样
只需要去遍历动态节点进行更新就可以。新策略将虚拟DOM节点渲染的性能与模板的大小
进行了解耦，变为与动态节点的数量有关。比2的性能大概高了2到5倍


Tree - Shaking:
2.0的现有限制是，无论你使不使用一些功能和方法，都要把它下下来。那在3的时候，它
将全局的API和内部的一些组件都通过ES的模块来进行导出。webpack这种打包工具在
打包的时候，Tree - Shaking就会更加友好。

//  Composition API:
//  主要有6个，比较要注意setup这个函数，替代了2里面我们常用的data()。同时3里面beforeCreate,
//  created两个生命周期，也将直接替换为setup()。

使用TypeScript

内部模块的解耦：
2.0的隐式耦合已经很严重了， 我们单独去理解源码的一部分的确比较困难，
在3里面，用到了一个monorepo结构。monorepo结构是把所有的模块都统一放在
一个主分支上面。如果有什么新的功能，拉一个分支出来去实现那个新的功能。

Composition API:
好处：之前代码重用的话使用mixin有很多问题，比如我们不知道它给我们的组件增加了什么。还可能导致与现有属性和函数名称冲突。
但composition API没有这种问题，因为它用到了什么对象方法都需要按需引入然后在setup函数中返回，所以我们知道从公共部分引入了哪些方法属性，所以很清晰。

定义 methods、watch、computed、data数据 等都放在了 setup() 函数中,
	然后返回它们，以便它们可以在模板中使用。 我们没有在setup函数返回的内容将在模板中不可用。setup()函数会在created()生命周期之前执行。
通过reactive()或者ref()可以创建一个响应式对象
computed() 用来创建计算属性，返回值是一个 ref() 实例。
readonly()传入一个响应式对象、普通对象或 ref ，返回一个只读的对象代理。
watchEffect() 会立即执行传入的函数，并响应式侦听其依赖，并在其依赖变更时重新运行该函数。
watch 和 Vue2.x 中是一样的，watch 需要侦听数据，并执行它的侦听回调。
isRef() 顾名思义，是用来判断某个值是否为 ref() 创建出来的响应式的值。
toRefs() 可以将 reactive() 创建出来的响应式对象转换成内容为 ref 响应式的值的普通对象