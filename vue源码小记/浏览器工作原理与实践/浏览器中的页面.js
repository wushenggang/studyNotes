21：
http请求基础流程：发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，
然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。

优化时间线上耗时项 Network - Timing
1，排队(Queuing时间过久)
大概率是由浏览器为每个域名最多维护 6 个连接导致的，可以采用域名分片技术，或者把站点升级到http2
2，第一字节时间(TTFB)时间过久
原因有可能如下：
（1）：服务器生成页面数据的时间过久
（2）网络的原因
（3）发送请求头时带上了多余的用户信息（比如一些多余的Cookie信息，加大了服务器的处理时长）
第一种问题可以想办法提高服务器的处理速度，比如增加各种缓存的技术，第二种问题可以使用CDN来缓存一些静态文件。第三种可以在请求时减少一些不必要的Cookie信息
3，Content Download时间过久
能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。
22：
CSS不阻塞dom的生成。CSS不阻塞js的加载，但是会阻塞js的执行。js会阻塞dom的生成，也就是会阻塞页面的渲染，那么css也有可能会阻塞页面的渲染。
如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，也不会阻塞JS，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，
而不是在解析DOM的时候，并行解析CSS。并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。
所以应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，
从而使页面尽快的渲染完成。

async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前
defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前

总结：
1. 首先介绍了什么是DOM（表述渲染引擎内部数据结构，它将Web页面和JavaScript脚本连接起来，并过滤不安全内容）、DOM树如何生成（网络进程和渲染进程建立一个流式管道，HTML解析器直接解析，不需要等待text / html类型的接口接受完毕再进行解析），第一步：通过分词器将字节流转换为Token；第二步：将Token解析为DOM节点；第三步：将DOM节点添加到DOM树中。
2. JavaScript是如何影响DOM生成的？暂停html解析，下载解析执行完毕js之后再进行html解析（如果这期间使用到了cssDom，需要等待相应css过程）。预解析线程的优化（提前加载相应js css文件）
3. 渲染引擎还有一个安全检查模块XSSAuditor用来检测词法安全的

23：
如果想要缩短白屏时长，可以有以下策略：
1，尽量减少文件大小，比如通过webpack等工具移除一些不必要的注释，并压缩javascript文件。
2，还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer
3，对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。

24:
需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。
这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

1, 常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，
比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。这也是 CSS 动画比 JavaScript 动画高效的原因。
2, 可以使用 will - change 来告诉渲染引擎你对该元素做一些特效变换，CSS 代码如下：
.box {
  will - change: transform, opacity;
}
这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，
渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。

25:
一个页面从生命周期的维度主要分为三个阶段：加载阶段、交互阶段、关闭阶段。
1. 加载阶段影响网页首次渲染的关键资源几个指标：个数、大小、RTT（round trip time）。通常一个HTTP的数据包在14kb左右。
优化方式：（1）如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性
（2）JavaScript 和 CSS 改成内联的形式
（3）同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志
（4）可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容
（5）还可以使用 CDN 来减少每次 RTT 时长
2. 交互阶段的优化主要是指渲染进程渲染帧速度。如何让单个帧生成的速度变快呢？
   * 减少JavaScript脚本执行时间
方法：（1）可以将一次执行的函数分解为多个任务，使每次执行时间变短
（2）使用Web Workers（主线程之外的线程，但web workers中没有DOM，CSSOM环境，所以无法操作DOM，可以将一些和DOM操作无关且费时的任务放入进行执行）
  * 避免强制同步布局，添加 删除dom后计算样式布局是在另外一个任务中执行的，这时候获取样式信息，会将其变成同步任务。
   * 避免布局抖动
  * 合理利用CSS合成动画（标识 will - change 单独生成一个图层）
   * 避免频繁的垃圾回收。（尽量避免临时垃圾数据，优化存储结构，避免小颗粒对象产生）