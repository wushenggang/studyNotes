21：
http请求基础流程：发起一个 HTTP 请求之后，浏览器首先查找缓存，如果缓存没有命中，那么继续发起 DNS 请求获取 IP 地址，
然后利用 IP 地址和服务器端建立 TCP 连接，再发送 HTTP 请求，等待服务器响应；不过，如果服务器响应头中包含了重定向的信息，那么整个流程就需要重新再走一遍。

优化时间线上耗时项 Network - Timing
1，排队(Queuing时间过久)
大概率是由浏览器为每个域名最多维护 6 个连接导致的，可以采用域名分片技术，或者把站点升级到http2
2，第一字节时间(TTFB)时间过久
原因有可能如下：
（1）：服务器生成页面数据的时间过久
（2）网络的原因
（3）发送请求头时带上了多余的用户信息（比如一些多余的Cookie信息，加大了服务器的处理时长）
第一种问题可以想办法提高服务器的处理速度，比如增加各种缓存的技术，第二种问题可以使用CDN来缓存一些静态文件。第三种可以在请求时减少一些不必要的Cookie信息
3，Content Download时间过久
能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。
22：
CSS不阻塞dom的生成。CSS不阻塞js的加载，但是会阻塞js的执行。js会阻塞dom的生成，也就是会阻塞页面的渲染，那么css也有可能会阻塞页面的渲染。
如果把CSS放在文档的最后面加载执行，CSS不会阻塞DOM的生成，也不会阻塞JS，但是浏览器在解析完DOM后，要花费额外时间来解析CSS，
而不是在解析DOM的时候，并行解析CSS。并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。
所以应该把CSS放在文档的头部，尽可能的提前加载CSS；把JS放在文档的尾部，这样JS也不会阻塞页面的渲染。CSS会和JS并行解析，CSS解析也尽可能的不去阻塞JS的执行，
从而使页面尽快的渲染完成。

async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前
defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前

总结：
1. 首先介绍了什么是DOM（表述渲染引擎内部数据结构，它将Web页面和JavaScript脚本连接起来，并过滤不安全内容）、DOM树如何生成（网络进程和渲染进程建立一个流式管道，HTML解析器直接解析，不需要等待text / html类型的接口接受完毕再进行解析），第一步：通过分词器将字节流转换为Token；第二步：将Token解析为DOM节点；第三步：将DOM节点添加到DOM树中。
2. JavaScript是如何影响DOM生成的？暂停html解析，下载解析执行完毕js之后再进行html解析（如果这期间使用到了cssDom，需要等待相应css过程）。预解析线程的优化（提前加载相应js css文件）
3. 渲染引擎还有一个安全检查模块XSSAuditor用来检测词法安全的